{"meta":{"title":"codexc","subtitle":"","description":"","author":"hxc","url":"http://101.34.225.67","root":"/"},"pages":[{"title":"about","date":"2021-12-08T22:30:11.000Z","updated":"2021-12-08T22:30:36.553Z","comments":true,"path":"about/index.html","permalink":"http://101.34.225.67/about/index.html","excerpt":"","text":""},{"title":"yourdiy","date":"2021-12-08T22:30:52.000Z","updated":"2021-12-08T22:31:11.900Z","comments":true,"path":"yourdiy/index.html","permalink":"http://101.34.225.67/yourdiy/index.html","excerpt":"","text":""}],"posts":[{"title":"my gallery","slug":"my-gallery","date":"2021-12-09T00:06:27.000Z","updated":"2021-12-09T00:07:35.574Z","comments":true,"path":"2021/12/09/my-gallery/","link":"","permalink":"http://101.34.225.67/2021/12/09/my-gallery/","excerpt":"","text":"Gin框架[TOC] 1.Gin框架内容详解1.1 Gin 框架渲染模板时间有限后续补充这里。。 1.2 Gin框架返回Json格式数据​ 使用Gin框架返回Json格式进行交互有两种方法，一种是Map[string]interface{}，在gin框架中有设置了一个快捷的map，gin.H，他的数据类型就是map[string]interface。 ​ 第二种方法就是使用结构体，但是结构体中有一个问题，就是Context下面的返回json的Json方法使用的是默认库的反射机制，然而在Go中小写表示私有不能公有，所以如果前端需要小写的首字母，我们需要使用tag来进行定制化操作 123456789101112131415161718192021222324252627282930313233package ginLesson10import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)type Message struct &#123; Type string `json:&quot;type&quot;` //在这里进行了一个json的序列化的tag操作 Content string `json:&quot;content&quot;`&#125;func main() &#123; r := gin.Default() //创建一个默认路由 r.GET(&quot;/json&quot;, func(c *gin.Context) &#123; //当请求/json时，就会进行如下处理。。。 //方法一：map/* data := map[string]interface&#123;&#125;&#123; 自己定义的一个map类型 &quot;name&quot;: &quot;小王子&quot;, &quot;age&quot;: 18, &#125;*/ // 使用框架内嵌的数据类型H = map[string]interface&#123;&#125;/* data := gin.H&#123;&quot;name&quot;: &quot;小王子&quot;, &quot;age&quot;: 18&#125;*/ //系统内嵌的默认数据类型 //方法二：使用结构体 //此处仍然有私有和公有，如果前端要求返回小写开头的字段，可以使用tag标签进行反射处理 msg := Message&#123; &quot;SendMessage&quot;, &quot;This is hxc&quot;, &#125; c.JSON(http.StatusOK, msg) //返回一个json格式 &#125;) r.Run(&quot;:8080&quot;) //跑在8080端口&#125; 如上操作，如果我们使用方法一中的快捷方法，我们可以将赋值语句和c.JSON进行合并 1234c.JSON(http.StatusOK, gin.H&#123; &quot;xxx&quot;:xxx, &quot;xxx&quot;:&quot;Xxx&quot;,&#125;) 1.3 获取queryString参数​ 这一节的笔记主要是如何获取URL长得querystring参数，以及它的三种获取方法，还有URL中querystring的存在方式，笔记都在代码块中，不详细解释，唯一需要注意的地方就是三种方法的细微差别 1234567891011121314151617181920212223242526272829package ginLesson10import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() //GET请求在URL？后面的是querystring参数 //key=value形式，多个key-value可以使用&amp;连接 //eq： /web?query=杨超越&amp;age=18 r.GET(&quot;/web&quot;, func(c *gin.Context) &#123; //首先获取querystring的参数 name := c.Query(&quot;query&quot;)//通过Query获取请求中携带querystring的参数 //name := c.DefaultQuery(&quot;query&quot;, &quot;somebody&quot;) //寻找请求中携带querystring的参数，如果没有找到默认使用somebody //name, ok := c.GetQuery(&quot;query&quot;) //虚招请求中携带querystring的参数，找到返回值，true，没有找到返回”空字符串“false age := c.Query(&quot;age&quot;) //if !ok &#123; // name = &quot;somebody&quot; //&#125; //如此处理等于DefaultQuery c.JSON(http.StatusOK, gin.H&#123; &quot;name&quot;:name, &quot;age&quot;:age, &#125;) &#125;) r.Run(&quot;:8080&quot;)&#125; 1.4 获取form表单参数​ 以前的web登陆都是使用post+form表单进行验证与提交，这里的一些东西需要前端的基础，后续可以学习，一些细节的东西都注释在了代码里 main.go 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)//获取form表单提交的参数//一次请求对应一个相应//一开始进入login界面是get请求，当点击登陆提交之后变成了post请求//所以哪怕URL是同一个，因为请求方法的不同，返回的界面也是不同的func main() &#123; r := gin.Default() r.LoadHTMLFiles(&quot;./login.html&quot;) //模板解析在前 r.GET(&quot;/login&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;login.html&quot;, nil) &#125;) //写一个r.POST方法 r.POST(&quot;/login&quot;, func(c *gin.Context) &#123; //方法一：获取form表单中提交的数据 userName := c.PostForm(&quot;username&quot;) //key是HTML页面中的label下的input的参数 passWord := c.PostForm(&quot;password&quot;) // //方法二： userName = c.DefaultPostForm(&quot;username&quot;, &quot;somebody&quot;) passWord = c.DefaultPostForm(&quot;password&quot;, &quot;******&quot;) //方法三： userName, bool := c.GetPostForm(&quot;username&quot;) if !bool &#123; userName = &quot;justBuy&quot; &#125; //c.HTML(http.StatusOK,&quot;index.html&quot;,gin.H&#123; //此处就是返回HTML的写法，殊途同归 // &quot;username&quot;:userName, // &quot;password&quot;:passWord, //&#125;) c.JSON(http.StatusOK, gin.H&#123; //此处懒得做一个index界面，直接使用json格式返回 &quot;userName&quot;: userName, &quot;passWord&quot;: passWord, &#125;) &#125;) r.Run(&quot;:8080&quot;)&#125; login.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; &lt;!-- 这里的action指定了表单的请求发往哪个地址--&gt; &lt;label for=&quot;username&quot;&gt;username:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt; &lt;!-- 这里的name定义的就是PostForm中的key--&gt; &lt;br&gt; &lt;label for=&quot;password&quot;&gt;password:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;password&quot; id=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.5 获取URL路径参数老版本会出错，在下面会标识出来，这个比较简单。输入例子 ：localhost:8080/小王子/18 || localhost:8080/blog/2021/12 123456789101112131415161718192021222324252627282930package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)//获取请求中的path参数(URL参数)func main() &#123; r := gin.Default() //之前在这里会出现错误，因为冲突，看一眼就能看出来，后面做了优化 r.GET(&quot;/:name/:age&quot;, func(c *gin.Context) &#123; name := c.Param(&quot;name&quot;) age := c.Param(&quot;age&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;name&quot;:name, &quot;age&quot;:age, &#125;) &#125;) r.GET(&quot;/blog/:year/:month&quot;, func(c *gin.Context) &#123; year := c.Param(&quot;year&quot;) month := c.Param(&quot;month&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;year&quot;:year, &quot;month&quot;:month, &#125;) &#125;) r.Run(&quot;:8080&quot;)&#125; 1.6 参数绑定​ 参数绑定的主要作用在我看来就是当用户提交了一组数据，为了就是解决代码的复用性，多次的重复的去做一段变量复制的操作不精简，而在gin框架中则提供了bind一类的函数使得服务器可以将一组和结果提匹配的数据进行结合赋值，代码复用提供了可能。 ​ 直接上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)//这个方法适用很多种获得数据的方式：//1、提交form表单//2、querystring参数//3、原始row的json数据格式type UserInfo struct &#123; UserName string `form:&quot;username&quot; json:&quot;username&quot;` PassWord string `form:&quot;password&quot; json:&quot;password&quot;`&#125;//获取请求中的path参数(URL参数)func main() &#123; r := gin.Default() r.GET(&quot;/user&quot;, func(c *gin.Context) &#123; //userName := c.Query(&quot;username&quot;) //passWord := c.Query(&quot;password&quot;) //u := UserInfo&#123; // userName: userName, // passWord: passWord, //&#125; var u UserInfo // 定义一个userInfo类型的对象，然后使用这个对象去接收浏览器传送的数据 err := c.ShouldBind(&amp;u) //进行一个shouldBind的绑定，这里一定要传地址，因为结构体是一个值拷贝类型 if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;error&quot;: err.Error(), &#125;) &#125; else &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;status&quot;: &quot;ok&quot;, &#125;) &#125; &#125;) r.POST(&quot;/form&quot;, func(c *gin.Context) &#123; // 这里的作用就是处理form下面的post请求 var u UserInfo err := c.ShouldBind(&amp;u) //如果这里不能绑定会返回一个错误 if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;error&quot;: err.Error(), &#125;) &#125; else &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;status&quot;: &quot;ok&quot;, &#125;) &#125; &#125;) r.Run(&quot;:8080&quot;)&#125; 1.7 文件上传​ 单个文件上传和多个文件上传，多个文件上传和单个文件上传最大限制具体可以去看博客。 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; &quot;path&quot;)func main() &#123; r := gin.Default() r.LoadHTMLFiles(&quot;./index.html&quot;) //解析模板文件index.html r.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;index.html&quot;, nil) // get请求返回一个默认页面 &#125;) r.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; //从请求中读取文件 f, err := c.FormFile(&quot;f1&quot;) // 这里的name指的是在HTML页面中，给那个input设置的name if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123; &quot;error&quot;: err.Error(), &#125;) &#125; else &#123; //将读取到的文件保存到服务器的某一目录下(本地) //filePath := fmt.Sprintf(&quot;./%s&quot;, f.Filename) filePath := path.Join(&quot;./&quot;, f.Filename) //join字符串拼接 _ = c.SaveUploadedFile(f, filePath) c.JSON(http.StatusOK, gin.H&#123; &quot;status&quot;: &quot;ok&quot;, &#125;) &#125; &#125;) r.Run(&quot;:8080&quot;)&#125; 1.8 gin的重定向​ 一个redirect重定向，一个.request.URL.Path方法进行转发，转发后要进行一个handleContext的后续处理操作 1234567891011121314151617181920212223242526package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() //这个就是属于重定向 //大致用途就是未注册点击个人中心转到注册那里 r.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.Redirect(http.StatusMovedPermanently, &quot;http://sogo.com&quot;) &#125;) //这个是转发，将get/a的请求转发给/b r.GET(&quot;/a&quot;, func(c *gin.Context) &#123; c.Request.URL.Path = &quot;/b&quot; //把请求的URL进行修改 r.HandleContext(c) //后续的处理context &#125;) r.GET(&quot;/b&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;status&quot;:&quot;ok&quot;, &#125;) &#125;) &#125; 1.9 路由/路由组1.9.1 路由这里基本就是回顾一下请求的几种方式，一般都有一些约定俗成的东西在里面，上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() //一个普普通通的GET请求 //通常用来获取某些信息 r.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;GET&quot;, &#125;) &#125;) //一个可以获得文件、账号密码、FORM请求的一个POST请求 //提交某些东西，去创建某个东西 差不多就是提交创建的意思 r.POST(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;POST&quot;, &#125;) &#125;) //一个可以用于更新某个东西的PUT请求 //更新某一条用户的信息，修改部分数据 r.PUT(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;PUT&quot;, &#125;) &#125;) //一个可以用于删除某个东西的DELETE请求 r.DELETE(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;DELETE&quot;, &#125;) &#125;) //此外gin框架中还有一个Any请求，可以处理任意请求 //处理所有请求，大集合 r.Any(&quot;/user&quot;, func(c *gin.Context) &#123; switch c.Request.Method &#123; //在switch中最好是使用http包中定义的常量来进行判断，而不是自己写一个&quot;GET&quot;之类的方法 case http.MethodGet: c.JSON(http.StatusOK, gin.H&#123;&quot;method&quot;: &quot;GET&quot;&#125;) case http.MethodPost: c.JSON(http.StatusOK, gin.H&#123;&quot;method&quot;: &quot;POST&quot;&#125;) case http.MethodPut: c.JSON(http.StatusOK, gin.H&#123;&quot;method&quot;: &quot;PUT&quot;&#125;) case http.MethodDelete: c.JSON(http.StatusOK, gin.H&#123;&quot;method&quot;: &quot;DELETE&quot;&#125;) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;method&quot;: &quot;Any&quot;, &#125;) &#125;) r.GET(&quot;/video/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;/video/index&quot;, &#125;) &#125;) r.GET(&quot;/shop/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;/shop/index&quot;, &#125;) &#125;) //路径终归是有一个限度的，如果你访问了域名中根本不存在的路径，那么就会执行这个函数进行一个提示， //所有的未找到的路由都会来到这里进行处理 r.NoRoute(func(c *gin.Context) &#123; c.JSON(http.StatusNotFound, gin.H&#123;&quot;message&quot;: &quot;the message is come from web page&quot;&#125;) &#125;) r.Run(&quot;:8080&quot;)&#125; 1.9.2 路由组路由组相当于是一个组名，等同于给四个班起了一个七年级的名字，不需要完整的叫出七年级四班，直需要叫四班就会让人知道是七年级的四班。 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() //主要的功能就是将相同的前缀省略掉了 videoGroup := r.Group(&quot;/video&quot;) //在这里创建一个/video的路由组名，后续的get方法使用&#123;&#125;代码块包起来 &#123; videoGroup.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;/video/index&quot;&#125;) &#125;) videoGroup.GET(&quot;/login&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;/video/login&quot;&#125;) &#125;) &#125; shopGroup := r.Group(&quot;/shop&quot;) //在这里创建一个/shop的路由组名，后续的get方法使用&#123;&#125;代码块包起来 &#123; shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;/shop/index&quot;&#125;) &#125;) shopGroup.GET(&quot;/login&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;/shop/login&quot;&#125;) &#125;) &#125; r.Run(&quot;:8080&quot;)&#125; 这里是对于一段路由嵌套的补充！~~~ 123456789101112131415161718package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() videoGroup := r.Group(&quot;/video&quot;) //在这里创建一个/video的路由组名，后续的get方法使用&#123;&#125;代码块包起来 &#123; home := videoGroup.Group(&quot;home&quot;) home.GET(&quot;/person&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;/home/person&quot;&#125;) &#125;) &#125; r.Run(&quot;:8080&quot;)&#125; 1.10 中间件总结： 首先是中间件函数的形参必须是HandlerFunc类型，然后这个类型的**真实类型是一个func(*Context)**，这样的一个函数被称为中间件 可以选择全局注册中间件或者是在处理某一个请求中加入中间件，如果是全局的话需要使用r.Use()函数，在这个函数中中间件的执行顺序按照在函数中排列的顺序进行执行 在Context上下文中有C.Next()和C.Abort()两种处理后续请求的方式，一个是调用该请求的剩下的请求，Abort是停止调用后续的请求，具体的实例可以看下面的代码段，类似于递归 补充上一点：在Next后面进行return会直接退出函数，然后如果没有next和abort，函数依次执行 在Context上下文中，可以使用Get和Set来进行跨中间件获得值，以此两大函数下面有些许延伸…… 然后就是路由组加入中间件的方法，具体也在代码段中贴出。 gin.Default()默认使用了 Logger 和Recovery中间件，其中： Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE = release Recovery中间件会recover任何panic。如果有panic的话，则会写入500响应码 如果不想使用上述的两个中间件，可以进行gin.New来进行一个没有任何中间件的路由 如果想在中间件中使用goroutine 当中间件或handler想启用新的goroutine时，不能使用原始的上下文的*gin.Context，必须使用上下文的只读副本，即c.Copy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package mainimport ( &quot;fmt&quot; &quot;net/http&quot; &quot;time&quot; &quot;github.com/gin-gonic/gin&quot;)// 统计耗时// 在这里的c.Next()m1和m2的执行顺序需要注意：// 1、先执行m1，然后进入c.Next，然后执行第二个中间件函数，// 然后退出第二个中间件函数，继续执行第一个函数的后续部分func m1(c *gin.Context) &#123; fmt.Println(&quot;m1 in&quot;) fmt.Println(&quot;this is m1&quot;) start := time.Now() c.Next() //调用该请求的剩余处理程序 //c.Abort() //停止调用请求的剩余程序 cost := time.Since(start) fmt.Printf(&quot;cost:%v\\n&quot;, cost) fmt.Println(&quot;m1 out&quot;)&#125;func m2(c *gin.Context) &#123; fmt.Println(&quot;m2 in&quot;) // c.Next() // c.Abort() // 如果我在这里开启一个Abort，页面不会得到返回，后续的indexHandler也不会返回json // 因为后续的indexHandler根本就不会执行 // return // 如果这里有return则直接跳出，不会执行下一句m2 out c.Set(&quot;name&quot;, &quot;黄星陈&quot;) // 在上下文中设置一个值 fmt.Println(&quot;m2 out&quot;)&#125;func outMiddleWare(doCheck bool) gin.HandlerFunc &#123; // 接入数据库之类的初始化工作 return func(c *gin.Context) &#123; if doCheck &#123; // 具体的逻辑 // 登录啊什么的 &#125; else &#123; c.Next() // 都完成直接放行 &#125; &#125;&#125;func indexHandler(c *gin.Context) &#123; fmt.Println(&quot;this is index&quot;) name, ok := c.Get(&quot;name&quot;) // 在上下文中取值， 跨中间件取值 if !ok &#123; name = &quot;anonymous&quot; &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: name&#125;)&#125;// 如果中间件没有写Next和Abort// 那么就依次执行// 这里的意思就是把匿名的函数变成了一个可以单独拿出来的函数func main() &#123; r := gin.Default() r.Use(m1, m2, outMiddleWare(true)) // 全局注册中间件函数m1, m2 // 等于在全局中先调用m1函数 r.GET(&quot;/index&quot;, indexHandler) //执行的顺序是从左到右 r.GET(&quot;/home&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;/home&quot;, &#125;) &#125;) r.GET(&quot;/person&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;message&quot;: &quot;/person&quot;, &#125;) &#125;) // 路由组加中间件函数的方法 // 方法一： //xxGroup := r.Group(&quot;/xx&quot;, outMiddleWare(true)) //&#123; // xxGroup.GET(&quot;/index&quot;, func(c *gin.Context) &#123; // c.JSON(http.StatusOK, gin.H&#123; // &quot;msg&quot;: &quot;this is xx/index&quot;, // &#125;) // &#125;) //&#125; //// 方法二： 使用xxx.Use( function ) //xx2Group := r.Group(&quot;/xx2&quot;) //xx2Group.Use(outMiddleWare(true)) //&#123; // xx2Group.GET(&quot;/index&quot;, func(c *gin.Context) &#123; // c.JSON(http.StatusOK, gin.H&#123; // &quot;msg&quot;: &quot;this is xx2Group/index&quot;, // &#125;) // &#125;) //&#125; r.Run(&quot;:8080&quot;)&#125; 2. ORM2.1 什么是ORMObject Relational Mapping 是称呼 Object 对象: 程序中的对象/实例，例如Go之中的结构体实例 Relational 关系: 关系型数据库，例如MySQL、Sqlserver Mapping 映射: 2.2 ORM优缺点优点：提高开发效率 缺点： 牺牲执行性能 牺牲灵活性 弱化SQL能力 在一些小项目中可以使用ORM，其余的时候还是建议直接使用SQL语句。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; &quot;github.com/jinzhu/gorm&quot; _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;)//对应的数据表type UserInfo struct &#123; Name string Age int Gender string Hobby string&#125;func main() &#123; //连接MySQL数据库 db, err := gorm.Open(&quot;mysql&quot;, &quot;root:root@(127.0.0.1:3306)/userinfo?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;) if err != nil &#123; panic(err) &#125; //创建表，自动迁移(把数据库和结构表进行对应) db.AutoMigrate(&amp;UserInfo&#123;&#125;) //创建数据行 //u1 := &amp;UserInfo&#123;Name: &quot;王新宇&quot;, Age: 18, Gender: &quot;男&quot;, Hobby: &quot;男&quot;&#125; //db.Create(u1) //查询数据 var u UserInfo db.First(&amp;u) //查询表中第一条数据保存到U中 fmt.Printf(&quot;U:%#v\\n&quot;, u) //这里是更新某一行的某一个字段的数据 db.Model(&amp;u).Update(&quot;hobby&quot;, &quot;双色球&quot;) //删除 db.Delete(&amp;u)&#125; 2.3 GORM Model在使用GORM工具的时候，通常我们需要在GORM中定义一个模型用来与数据库中的表进行一个映射关系，在GORM中的模型通常可以是正常定义的结构体，基本类型或他们的指针，同时也支持Sql.Scannner和Driver.valuer接口(interface) 2.3.1 gorm.Model为了方便模型的定义,GORM中内置了一个结构体gorm.Model。它包含了一个ID，CreatedAt，updateAt，DeleteAt四个字段的结构体。 123456type Model struct &#123; ID uint `gorm:&quot;primary_key&quot;` CreatedAt time.Time //数据初次创建的时间 UpdatedAt time.Time //每次更新的时间 DeletedAt *time.Time `sql:&quot;index&quot;` //调用delete删除该数据时，会在这里记下一个时间，并不会真正的删除它，软删除&#125; 可以进行嵌套 1234type User struct &#123; Name string gorm.Model&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;database/sql&quot; &quot;github.com/jinzhu/gorm&quot; _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot; &quot;time&quot;)type User struct &#123; gorm.Model //内嵌结构体类型 Name string Age sql.NullInt64 //零值类型 Birthday *time.Time `gorm:&quot;column:User_Birthday&quot;` //用这个去映射这个表的数据行的名字 Email string `gorm:&quot;type:varchar(100);unique_index&quot;` //varchar(100)，且该字段唯一 Role string `gorm:&quot;size:255&quot;` MemberNumber *string `gorm:&quot;unique;not null&quot;` //这里默认会将驼峰命名法变成_连接的法则 Num int `gorm:&quot;AUTO_INCREMENT&quot;` Address string `gorm:&quot;index:addr&quot;` IgnoreMe int `gorm:&quot;-&quot;`&#125;type Member struct &#123; MemberId int `gorm:&quot;primary_key&quot;` //通过这个tag指定 MemberId为主键 Name string Age int Skill string&#125;func (Member) TableName() string &#123; // 当某个类型有一个方法名字是TableName时， // 并且返回值是string，通常而言就是满足这个接口之后， // 这个表的名字就会被命名为它的返回的字符串 return &quot;Member&quot; //在这里指定之后就default就不会修改了&#125;func main() &#123; //指定一个默认的前缀，数据表 //简单的一个处理默认表名的函数 //只会修改默认的操作 gorm.DefaultTableNameHandler = func(db *gorm.DB, defaultTableName string) string &#123; return &quot;SMS_&quot; + defaultTableName //指定名字 &#125; db, err := gorm.Open(&quot;mysql&quot;, &quot;root:root@(127.0.0.1:3306)/userinfo?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;) if err != nil &#123; panic(err) &#125; defer db.Close() db.SingularTable(false) //禁用复数 db.AutoMigrate(&amp;User&#123;&#125;) //存在表时不会再去删除这个表，最大程度上保证你的安全 db.AutoMigrate(&amp;Member&#123;&#125;) //使用User结构体创建于一个名为test的数据表 db.Table(&quot;test&quot;).CreateTable(&amp;User&#123;&#125;)&#125; 2.3.2 GORM默认值和记录的创建12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;github.com/jinzhu/gorm&quot; _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;)type User struct &#123; ID int // 默认的主键ID Name string Age int Skill string Hobby string `gorm:&quot;default:&#x27;吃饭&#x27;&quot;`&#125;func main() &#123; db, err := gorm.Open(&quot;mysql&quot;, &quot;root:root@(127.0.0.1:3306)/userinfo?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;) if err != nil &#123; panic(err) &#125; defer db.Close() db.SingularTable(false) db.AutoMigrate(&amp;User&#123;&#125;) // 结构体和数据库对应起来 u := &amp;User&#123;Name: &quot;黄星陈&quot;, Age: 18, Skill: &quot;没能力&quot; &#125; fmt.Println(db.NewRecord(&amp;u)) // 判断主键是否为空 true 确实不存在 db.Create(&amp;u) // 在数据库中创建一条数据 fmt.Println(db.NewRecord(&amp;u)) // 判断主键是否为空 false 确实不存在&#125; 默认值： 使用tag来指定默认值 1234567type User struct &#123; ID int // 默认的主键ID Name string Age int Skill string Hobby string `gorm:&quot;default:&#x27;吃饭&#x27;&quot;` // 这里就是指定的默认值,如果外面是双引号里面要用单引号&#125; 如果你配有默认值，但是使用的是零值，比如nil，空串，0，gorm就会使用默认值，如果想解决可以使用指针来解决 12345678type User struct &#123; ID int // 默认的主键ID Name string Age int Skill string Hobby *string `gorm:&quot;default:&#x27;吃饭&#x27;&quot;` // 这里就是指定的默认值,如果外面是双引号里面要用单引号&#125;u := &amp;User&#123;Name: &quot;黄星陈&quot;, Age: 18, Skill: &quot;没能力&quot;, Hobby: new(string) &#125; 或者是第二种办法 12345678type User struct &#123; ID int // 默认的主键ID Name string Age int Skill string Hobby sql.NullString`gorm:&quot;default:&#x27;吃饭&#x27;&quot;` // 这里就是指定的默认值,如果外面是双引号里面要用单引号&#125; u := &amp;User&#123;Name: &quot;黄星陈&quot;, Age: 18, Skill: &quot;没能力&quot;, Hobby: sql.NullString&#123;String: &quot;&quot;, Valid: true&#125;&#125; 活学活用了属于是 12345678type User struct &#123; ID int // 默认的主键ID Name string Age sql.NullInt32 `gorm:&quot;default:20` Skill string Hobby sql.NullString `gorm:&quot;default:&#x27;吃饭&#x27;&quot;`&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-12-08T12:51:39.321Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/12/08/hello-world/","link":"","permalink":"http://101.34.225.67/2021/12/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}